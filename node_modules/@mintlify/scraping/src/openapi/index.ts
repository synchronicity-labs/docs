import SwaggerParser from '@apidevtools/swagger-parser';
import {
  DecoratedNavigation,
  DecoratedNavigationGroup,
  Navigation,
  NavigationEntry,
  NavigationGroup,
} from '@mintlify/models';
import { outputFile } from 'fs-extra';
import { join } from 'node:path';
import { OpenAPI, OpenAPIV3 } from 'openapi-types';

export const generateOpenApiPages = async (
  path: string,
  writeFiles?: boolean,
  outDir?: string
): Promise<{
  nav: Navigation;
  decoratedNav: DecoratedNavigation;
  spec: OpenAPI.Document;
}> => {
  const spec = await SwaggerParser.validate(path);
  if (spec.paths === undefined || Object.keys(spec.paths).length === 0) {
    throw new Error('No paths defined.');
  }

  const nav: Navigation = [];
  const decoratedNav: DecoratedNavigation = [];

  Object.entries(spec.paths).forEach(([path, pathItemObject]) => {
    if (pathItemObject === undefined) {
      return;
    }
    Object.values(OpenAPIV3.HttpMethods).forEach((method) => {
      if (method in pathItemObject) {
        const operation = pathItemObject[method];
        const groupName = operation?.tags?.[0];
        const title =
          prepareStringToBeValidFilename(operation?.summary) ??
          `${method}-${prepareStringToBeValidFilename(path)}`;
        const folder = prepareStringToBeValidFilename(groupName) ?? '';
        const base = join(outDir ?? '', folder, title);

        const navGroup = findNavGroup<NavigationGroup>(nav, groupName);
        const decoratedNavGroup = findNavGroup<DecoratedNavigationGroup>(decoratedNav, groupName);

        const filenameWithoutExtension = generateUniqueFilenameWithoutExtension(navGroup, base);
        navGroup.push(filenameWithoutExtension);
        decoratedNavGroup.push({
          openapi: `${method} ${path}`,
          href: join('/', filenameWithoutExtension),
        });

        writeFiles && createOpenApiFrontmatter(`${filenameWithoutExtension}.mdx`, method, path);
      }
    });
  });

  return {
    nav,
    decoratedNav,
    spec,
  };
};

// returns the group with the given group name, or the top-level group if no group name is provided
const findNavGroup = <T extends NavigationGroup | DecoratedNavigationGroup>(
  nav: T['pages'][number][],
  groupName?: string
): T['pages'][number][] => {
  if (groupName === undefined) {
    return nav;
  } else {
    const group = nav.find(
      (fileOrGroup) =>
        typeof fileOrGroup === 'object' && 'group' in fileOrGroup && fileOrGroup.group === groupName
    ) as T;
    if (group === undefined) {
      const newGroup = {
        group: groupName,
        pages: [],
      };
      nav.push(newGroup);
      return newGroup.pages;
    } else {
      return group.pages;
    }
  }
};

// returns a filename that is unique within the given array of pages
const generateUniqueFilenameWithoutExtension = (pages: NavigationEntry[], base: string): string => {
  let filename = base;
  if (pages.includes(filename)) {
    let extension = 1;
    filename = `${base}-${extension}`;
    while (pages.includes(filename)) {
      extension += 1;
      filename = `${base}-${extension}`;
    }
  }
  return filename;
};

const createOpenApiFrontmatter = async (
  filename: string,
  method: OpenAPIV3.HttpMethods,
  path: string
) => {
  const data = `---
openapi: ${method} ${path}
---`;

  outputFile(filename, data);
};

export const prepareStringToBeValidFilename = (str?: string) =>
  str
    ? str
        .replaceAll(' ', '-')
        .replace(/\{.*?\}/g, '-') // remove path parameters
        .replace(/^-/, '')
        .replace(/-$/, '')
        .replace(/[{}(),.'\n\/]/g, '') // remove special characters
        .replaceAll(/--/g, '-') // replace double hyphens
        .toLowerCase()
    : undefined;
